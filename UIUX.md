- Use Next.js + Tailwind CSS + shadcn/ui + Radix primitives as the default UI stack for every new interface.
- Use Python for backend/service scripts where it is the fastest, clearest implementation path.
- Keep UI architecture modular and component-driven; do not ship page-specific one-off UI controls when a reusable component pattern exists.
- Keep every screen minimal by default; show only actions that work today and remove placeholders or non-functional UI copy.
- Prefer fewer words on screen; keep helper text concise and task-focused.
- Keep one clear primary action per context region and prevent secondary actions from competing visually.
- Place destructive actions as subtle icon-only controls at card/row top-right whenever possible.
- Require confirmation for destructive actions to prevent accidental clicks even when icons are subtle.
- Ensure destructive controls have clear `aria-label` and `title` text for accessibility.
- Ensure all buttons, links, badges, and input borders have strong contrast in both light and dark themes.
- Keep theme switching as a single icon control in the top-right header area.
- Ensure the theme icon always remains visible and reachable on desktop and mobile.
- Never rely on global anchor styles to color button links; button text must inherit button variant colors.
- Validate every UI change in both light and dark themes before merging.
- Preserve generous whitespace and spacing rhythm; do not crowd cards with unnecessary action buttons.
- Keep cards visually calm with soft borders and restrained shadows; avoid heavy visual noise.
- Keep filters and controls aligned in responsive rows so text is never truncated or clipped.
- Keep layouts responsive across desktop and mobile with readable widths and comfortable tap targets.
- Keep sidebars structurally consistent with top-level navigation and predictable item ordering.
- Provide a ChatGPT-style sidebar hide/show affordance with a clear collapse/expand icon.
- In collapsed sidebar mode, show icon-only navigation and reveal labels immediately on hover.
- Support sidebar resizing on desktop with min/max width constraints and persist user preference locally.
- Persist sidebar collapsed state and width across reloads for continuity.
- In collapsed sidebar mode, keep icon-only nav with tooltips/titles so navigation remains discoverable.
- Keep upload-to-processing workflows asynchronous; users must be able to navigate while jobs continue.
- Show job progress and stage logs clearly for long-running operations.
- Group extracted video frames as one clip-level dataset item instead of exposing raw frame clutter by default.
- Route grouped video items to a clip-level viewer page instead of forcing first-frame annotation entry.
- Show clip-level summaries (frames, boxes, classes, job status) before frame-level details.
- Provide direct download for annotated artifacts when available and clear fallback messaging when not available yet.
- Keep annotation overlays readable; label text must remain legible across varied backgrounds.
- Use model outputs directly where possible; keep post-processing transparent, minimal, and deterministic.
- For identity detection in sports workflows, treat names as possible identities and never guaranteed facts.
- Only surface person identity labels when evidence is strong and confidence passes threshold; otherwise use unknown/null.
- Keep reasoning controls generic (low/medium/high) rather than hardcoding per-use-case UI dropdowns.
- Keep dataset and project management actions explicit, reversible where possible, and clearly scoped.
- Prefer icon size and placement consistency across project, dataset, review, and settings surfaces.
- Keep keyboard focus rings visible on all interactive elements.
- Ensure empty/loading/error/success states exist for every major workflow.
- Use Playwright screenshot sweeps for visual QA on key routes after major UI changes.
- Store Playwright QA artifacts under `output/playwright/` to keep verification reproducible.
- Do not add new dependencies unless absolutely necessary for product quality or maintainability.
- Run typecheck, lint, and tests before pushing UI changes to `main`.
- Update this file whenever a new UI pattern becomes a standard rule for future agents.
